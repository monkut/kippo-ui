/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Kippo Project Management API
 * REST API for managing Kippo projects, tasks, and effort tracking
 * OpenAPI spec version: 1.1.0
 */
import type {
  ErrorResponse,
  PaginatedProjectAssumptionList,
  PaginatedProjectBusinessRequirementCategoryList,
  PaginatedProjectBusinessRequirementCommentList,
  PaginatedProjectBusinessRequirementEstimateList,
  PaginatedProjectBusinessRequirementListList,
  PaginatedProjectProblemDefinitionList,
  PaginatedProjectTechnicalRequirementCategoryList,
  PaginatedProjectTechnicalRequirementCommentList,
  PaginatedProjectTechnicalRequirementGithubIssueList,
  PaginatedProjectTechnicalRequirementList,
  PatchedProjectAssumptionRequest,
  PatchedProjectBusinessRequirementCategoryRequest,
  PatchedProjectBusinessRequirementCommentRequest,
  PatchedProjectBusinessRequirementEstimateRequest,
  PatchedProjectBusinessRequirementRequest,
  PatchedProjectProblemDefinitionRequest,
  PatchedProjectTechnicalRequirementCategoryRequest,
  PatchedProjectTechnicalRequirementCommentRequest,
  PatchedProjectTechnicalRequirementGithubIssueRequest,
  PatchedProjectTechnicalRequirementRequest,
  ProjectAssumption,
  ProjectAssumptionRequest,
  ProjectBusinessRequirement,
  ProjectBusinessRequirementCategory,
  ProjectBusinessRequirementCategoryRequest,
  ProjectBusinessRequirementComment,
  ProjectBusinessRequirementCommentRequest,
  ProjectBusinessRequirementDetail,
  ProjectBusinessRequirementEstimate,
  ProjectBusinessRequirementEstimateRequest,
  ProjectBusinessRequirementRequest,
  ProjectProblemDefinition,
  ProjectProblemDefinitionRequest,
  ProjectTechnicalRequirement,
  ProjectTechnicalRequirementCategory,
  ProjectTechnicalRequirementCategoryRequest,
  ProjectTechnicalRequirementComment,
  ProjectTechnicalRequirementCommentRequest,
  ProjectTechnicalRequirementDetail,
  ProjectTechnicalRequirementGithubIssue,
  ProjectTechnicalRequirementGithubIssueRequest,
  ProjectTechnicalRequirementRequest,
  RequirementsAssumptionsCategoriesRetrieve200,
  RequirementsAssumptionsListParams,
  RequirementsBusinessRequirementCategoriesListParams,
  RequirementsBusinessRequirementCommentsListParams,
  RequirementsBusinessRequirementsListParams,
  RequirementsEstimatesListParams,
  RequirementsGithubIssuesListParams,
  RequirementsProblemDefinitionsListParams,
  RequirementsTechnicalRequirementCategoriesListParams,
  RequirementsTechnicalRequirementCommentsListParams,
  RequirementsTechnicalRequirementsListParams,
  ScheduleEstimationRequestRequest,
  ScheduleEstimationResponse
} from '.././models';

import { customFetch } from '../../custom-fetch';

/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsListResponse200 = {
  data: PaginatedProjectAssumptionList
  status: 200
}
    
export type requirementsAssumptionsListResponseSuccess = (requirementsAssumptionsListResponse200) & {
  headers: Headers;
};
;

export type requirementsAssumptionsListResponse = (requirementsAssumptionsListResponseSuccess)

export const getRequirementsAssumptionsListUrl = (params?: RequirementsAssumptionsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/assumptions/?${stringifiedParams}` : `/api/requirements/assumptions/`
}

export const requirementsAssumptionsList = async (params?: RequirementsAssumptionsListParams, options?: RequestInit): Promise<requirementsAssumptionsListResponse> => {
  
  return customFetch<requirementsAssumptionsListResponse>(getRequirementsAssumptionsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsCreateResponse201 = {
  data: ProjectAssumption
  status: 201
}
    
export type requirementsAssumptionsCreateResponseSuccess = (requirementsAssumptionsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsAssumptionsCreateResponse = (requirementsAssumptionsCreateResponseSuccess)

export const getRequirementsAssumptionsCreateUrl = () => {


  

  return `/api/requirements/assumptions/`
}

export const requirementsAssumptionsCreate = async (projectAssumptionRequest: ProjectAssumptionRequest, options?: RequestInit): Promise<requirementsAssumptionsCreateResponse> => {
  
  return customFetch<requirementsAssumptionsCreateResponse>(getRequirementsAssumptionsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectAssumptionRequest,)
  }
);}


/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsRetrieveResponse200 = {
  data: ProjectAssumption
  status: 200
}
    
export type requirementsAssumptionsRetrieveResponseSuccess = (requirementsAssumptionsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsAssumptionsRetrieveResponse = (requirementsAssumptionsRetrieveResponseSuccess)

export const getRequirementsAssumptionsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/assumptions/${id}/`
}

export const requirementsAssumptionsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsAssumptionsRetrieveResponse> => {
  
  return customFetch<requirementsAssumptionsRetrieveResponse>(getRequirementsAssumptionsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsUpdateResponse200 = {
  data: ProjectAssumption
  status: 200
}
    
export type requirementsAssumptionsUpdateResponseSuccess = (requirementsAssumptionsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsAssumptionsUpdateResponse = (requirementsAssumptionsUpdateResponseSuccess)

export const getRequirementsAssumptionsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/assumptions/${id}/`
}

export const requirementsAssumptionsUpdate = async (id: number,
    projectAssumptionRequest: ProjectAssumptionRequest, options?: RequestInit): Promise<requirementsAssumptionsUpdateResponse> => {
  
  return customFetch<requirementsAssumptionsUpdateResponse>(getRequirementsAssumptionsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectAssumptionRequest,)
  }
);}


/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsPartialUpdateResponse200 = {
  data: ProjectAssumption
  status: 200
}
    
export type requirementsAssumptionsPartialUpdateResponseSuccess = (requirementsAssumptionsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsAssumptionsPartialUpdateResponse = (requirementsAssumptionsPartialUpdateResponseSuccess)

export const getRequirementsAssumptionsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/assumptions/${id}/`
}

export const requirementsAssumptionsPartialUpdate = async (id: number,
    patchedProjectAssumptionRequest: PatchedProjectAssumptionRequest, options?: RequestInit): Promise<requirementsAssumptionsPartialUpdateResponse> => {
  
  return customFetch<requirementsAssumptionsPartialUpdateResponse>(getRequirementsAssumptionsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectAssumptionRequest,)
  }
);}


/**
 * ViewSet for ProjectAssumption model.

Assumptions and constraints (å‰ææ¡ä»¶ã¨åˆ¶ç´„äº‹é …) for a project.

**Organization Scoping:**
- Regular users can only access assumptions for projects in their organizations
- Superusers can access all assumptions

**Filtering:**
- project: Filter by project UUID
- category: Filter by category (assumption or constraint)
 */
export type requirementsAssumptionsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsAssumptionsDestroyResponseSuccess = (requirementsAssumptionsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsAssumptionsDestroyResponse = (requirementsAssumptionsDestroyResponseSuccess)

export const getRequirementsAssumptionsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/assumptions/${id}/`
}

export const requirementsAssumptionsDestroy = async (id: number, options?: RequestInit): Promise<requirementsAssumptionsDestroyResponse> => {
  
  return customFetch<requirementsAssumptionsDestroyResponse>(getRequirementsAssumptionsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * Return available assumption category choices.
 */
export type requirementsAssumptionsCategoriesRetrieveResponse200 = {
  data: RequirementsAssumptionsCategoriesRetrieve200
  status: 200
}
    
export type requirementsAssumptionsCategoriesRetrieveResponseSuccess = (requirementsAssumptionsCategoriesRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsAssumptionsCategoriesRetrieveResponse = (requirementsAssumptionsCategoriesRetrieveResponseSuccess)

export const getRequirementsAssumptionsCategoriesRetrieveUrl = () => {


  

  return `/api/requirements/assumptions/categories/`
}

export const requirementsAssumptionsCategoriesRetrieve = async ( options?: RequestInit): Promise<requirementsAssumptionsCategoriesRetrieveResponse> => {
  
  return customFetch<requirementsAssumptionsCategoriesRetrieveResponse>(getRequirementsAssumptionsCategoriesRetrieveUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesListResponse200 = {
  data: PaginatedProjectBusinessRequirementCategoryList
  status: 200
}
    
export type requirementsBusinessRequirementCategoriesListResponseSuccess = (requirementsBusinessRequirementCategoriesListResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesListResponse = (requirementsBusinessRequirementCategoriesListResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesListUrl = (params?: RequirementsBusinessRequirementCategoriesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/business-requirement-categories/?${stringifiedParams}` : `/api/requirements/business-requirement-categories/`
}

export const requirementsBusinessRequirementCategoriesList = async (params?: RequirementsBusinessRequirementCategoriesListParams, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesListResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesListResponse>(getRequirementsBusinessRequirementCategoriesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesCreateResponse201 = {
  data: ProjectBusinessRequirementCategory
  status: 201
}
    
export type requirementsBusinessRequirementCategoriesCreateResponseSuccess = (requirementsBusinessRequirementCategoriesCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesCreateResponse = (requirementsBusinessRequirementCategoriesCreateResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesCreateUrl = () => {


  

  return `/api/requirements/business-requirement-categories/`
}

export const requirementsBusinessRequirementCategoriesCreate = async (projectBusinessRequirementCategoryRequest: ProjectBusinessRequirementCategoryRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesCreateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesCreateResponse>(getRequirementsBusinessRequirementCategoriesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesRetrieveResponse200 = {
  data: ProjectBusinessRequirementCategory
  status: 200
}
    
export type requirementsBusinessRequirementCategoriesRetrieveResponseSuccess = (requirementsBusinessRequirementCategoriesRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesRetrieveResponse = (requirementsBusinessRequirementCategoriesRetrieveResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-categories/${id}/`
}

export const requirementsBusinessRequirementCategoriesRetrieve = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesRetrieveResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesRetrieveResponse>(getRequirementsBusinessRequirementCategoriesRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesUpdateResponse200 = {
  data: ProjectBusinessRequirementCategory
  status: 200
}
    
export type requirementsBusinessRequirementCategoriesUpdateResponseSuccess = (requirementsBusinessRequirementCategoriesUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesUpdateResponse = (requirementsBusinessRequirementCategoriesUpdateResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-categories/${id}/`
}

export const requirementsBusinessRequirementCategoriesUpdate = async (id: number,
    projectBusinessRequirementCategoryRequest: ProjectBusinessRequirementCategoryRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesUpdateResponse>(getRequirementsBusinessRequirementCategoriesUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesPartialUpdateResponse200 = {
  data: ProjectBusinessRequirementCategory
  status: 200
}
    
export type requirementsBusinessRequirementCategoriesPartialUpdateResponseSuccess = (requirementsBusinessRequirementCategoriesPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesPartialUpdateResponse = (requirementsBusinessRequirementCategoriesPartialUpdateResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-categories/${id}/`
}

export const requirementsBusinessRequirementCategoriesPartialUpdate = async (id: number,
    patchedProjectBusinessRequirementCategoryRequest: PatchedProjectBusinessRequirementCategoryRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesPartialUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesPartialUpdateResponse>(getRequirementsBusinessRequirementCategoriesPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectBusinessRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementCategory model.

Categories for organizing business requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsBusinessRequirementCategoriesDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsBusinessRequirementCategoriesDestroyResponseSuccess = (requirementsBusinessRequirementCategoriesDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCategoriesDestroyResponse = (requirementsBusinessRequirementCategoriesDestroyResponseSuccess)

export const getRequirementsBusinessRequirementCategoriesDestroyUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-categories/${id}/`
}

export const requirementsBusinessRequirementCategoriesDestroy = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementCategoriesDestroyResponse> => {
  
  return customFetch<requirementsBusinessRequirementCategoriesDestroyResponse>(getRequirementsBusinessRequirementCategoriesDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsListResponse200 = {
  data: PaginatedProjectBusinessRequirementCommentList
  status: 200
}
    
export type requirementsBusinessRequirementCommentsListResponseSuccess = (requirementsBusinessRequirementCommentsListResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsListResponse = (requirementsBusinessRequirementCommentsListResponseSuccess)

export const getRequirementsBusinessRequirementCommentsListUrl = (params?: RequirementsBusinessRequirementCommentsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/business-requirement-comments/?${stringifiedParams}` : `/api/requirements/business-requirement-comments/`
}

export const requirementsBusinessRequirementCommentsList = async (params?: RequirementsBusinessRequirementCommentsListParams, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsListResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsListResponse>(getRequirementsBusinessRequirementCommentsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsCreateResponse201 = {
  data: ProjectBusinessRequirementComment
  status: 201
}
    
export type requirementsBusinessRequirementCommentsCreateResponseSuccess = (requirementsBusinessRequirementCommentsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsCreateResponse = (requirementsBusinessRequirementCommentsCreateResponseSuccess)

export const getRequirementsBusinessRequirementCommentsCreateUrl = () => {


  

  return `/api/requirements/business-requirement-comments/`
}

export const requirementsBusinessRequirementCommentsCreate = async (projectBusinessRequirementCommentRequest: ProjectBusinessRequirementCommentRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsCreateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsCreateResponse>(getRequirementsBusinessRequirementCommentsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsRetrieveResponse200 = {
  data: ProjectBusinessRequirementComment
  status: 200
}
    
export type requirementsBusinessRequirementCommentsRetrieveResponseSuccess = (requirementsBusinessRequirementCommentsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsRetrieveResponse = (requirementsBusinessRequirementCommentsRetrieveResponseSuccess)

export const getRequirementsBusinessRequirementCommentsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-comments/${id}/`
}

export const requirementsBusinessRequirementCommentsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsRetrieveResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsRetrieveResponse>(getRequirementsBusinessRequirementCommentsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsUpdateResponse200 = {
  data: ProjectBusinessRequirementComment
  status: 200
}
    
export type requirementsBusinessRequirementCommentsUpdateResponseSuccess = (requirementsBusinessRequirementCommentsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsUpdateResponse = (requirementsBusinessRequirementCommentsUpdateResponseSuccess)

export const getRequirementsBusinessRequirementCommentsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-comments/${id}/`
}

export const requirementsBusinessRequirementCommentsUpdate = async (id: number,
    projectBusinessRequirementCommentRequest: ProjectBusinessRequirementCommentRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsUpdateResponse>(getRequirementsBusinessRequirementCommentsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsPartialUpdateResponse200 = {
  data: ProjectBusinessRequirementComment
  status: 200
}
    
export type requirementsBusinessRequirementCommentsPartialUpdateResponseSuccess = (requirementsBusinessRequirementCommentsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsPartialUpdateResponse = (requirementsBusinessRequirementCommentsPartialUpdateResponseSuccess)

export const getRequirementsBusinessRequirementCommentsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-comments/${id}/`
}

export const requirementsBusinessRequirementCommentsPartialUpdate = async (id: number,
    patchedProjectBusinessRequirementCommentRequest: PatchedProjectBusinessRequirementCommentRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsPartialUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsPartialUpdateResponse>(getRequirementsBusinessRequirementCommentsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectBusinessRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementComment model.

Comments on business requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by business requirement ID
- top_level_only: Return only top-level comments (true/false)

**Actions:**
- toggle_resolved: Toggle the is_resolved status for a top-level comment
 */
export type requirementsBusinessRequirementCommentsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsBusinessRequirementCommentsDestroyResponseSuccess = (requirementsBusinessRequirementCommentsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsDestroyResponse = (requirementsBusinessRequirementCommentsDestroyResponseSuccess)

export const getRequirementsBusinessRequirementCommentsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-comments/${id}/`
}

export const requirementsBusinessRequirementCommentsDestroy = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsDestroyResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsDestroyResponse>(getRequirementsBusinessRequirementCommentsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * Toggle the is_resolved status for a top-level comment.
 */
export type requirementsBusinessRequirementCommentsToggleResolvedCreateResponse200 = {
  data: ProjectBusinessRequirementComment
  status: 200
}
    
export type requirementsBusinessRequirementCommentsToggleResolvedCreateResponseSuccess = (requirementsBusinessRequirementCommentsToggleResolvedCreateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementCommentsToggleResolvedCreateResponse = (requirementsBusinessRequirementCommentsToggleResolvedCreateResponseSuccess)

export const getRequirementsBusinessRequirementCommentsToggleResolvedCreateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirement-comments/${id}/toggle_resolved/`
}

export const requirementsBusinessRequirementCommentsToggleResolvedCreate = async (id: number,
    projectBusinessRequirementCommentRequest: ProjectBusinessRequirementCommentRequest, options?: RequestInit): Promise<requirementsBusinessRequirementCommentsToggleResolvedCreateResponse> => {
  
  return customFetch<requirementsBusinessRequirementCommentsToggleResolvedCreateResponse>(getRequirementsBusinessRequirementCommentsToggleResolvedCreateUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsListResponse200 = {
  data: PaginatedProjectBusinessRequirementListList
  status: 200
}
    
export type requirementsBusinessRequirementsListResponseSuccess = (requirementsBusinessRequirementsListResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsListResponse = (requirementsBusinessRequirementsListResponseSuccess)

export const getRequirementsBusinessRequirementsListUrl = (params?: RequirementsBusinessRequirementsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/business-requirements/?${stringifiedParams}` : `/api/requirements/business-requirements/`
}

export const requirementsBusinessRequirementsList = async (params?: RequirementsBusinessRequirementsListParams, options?: RequestInit): Promise<requirementsBusinessRequirementsListResponse> => {
  
  return customFetch<requirementsBusinessRequirementsListResponse>(getRequirementsBusinessRequirementsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsCreateResponse201 = {
  data: ProjectBusinessRequirement
  status: 201
}
    
export type requirementsBusinessRequirementsCreateResponseSuccess = (requirementsBusinessRequirementsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsCreateResponse = (requirementsBusinessRequirementsCreateResponseSuccess)

export const getRequirementsBusinessRequirementsCreateUrl = () => {


  

  return `/api/requirements/business-requirements/`
}

export const requirementsBusinessRequirementsCreate = async (projectBusinessRequirementRequest: ProjectBusinessRequirementRequest, options?: RequestInit): Promise<requirementsBusinessRequirementsCreateResponse> => {
  
  return customFetch<requirementsBusinessRequirementsCreateResponse>(getRequirementsBusinessRequirementsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsRetrieveResponse200 = {
  data: ProjectBusinessRequirementDetail
  status: 200
}
    
export type requirementsBusinessRequirementsRetrieveResponseSuccess = (requirementsBusinessRequirementsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsRetrieveResponse = (requirementsBusinessRequirementsRetrieveResponseSuccess)

export const getRequirementsBusinessRequirementsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/business-requirements/${id}/`
}

export const requirementsBusinessRequirementsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementsRetrieveResponse> => {
  
  return customFetch<requirementsBusinessRequirementsRetrieveResponse>(getRequirementsBusinessRequirementsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsUpdateResponse200 = {
  data: ProjectBusinessRequirement
  status: 200
}
    
export type requirementsBusinessRequirementsUpdateResponseSuccess = (requirementsBusinessRequirementsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsUpdateResponse = (requirementsBusinessRequirementsUpdateResponseSuccess)

export const getRequirementsBusinessRequirementsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirements/${id}/`
}

export const requirementsBusinessRequirementsUpdate = async (id: number,
    projectBusinessRequirementRequest: ProjectBusinessRequirementRequest, options?: RequestInit): Promise<requirementsBusinessRequirementsUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementsUpdateResponse>(getRequirementsBusinessRequirementsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsPartialUpdateResponse200 = {
  data: ProjectBusinessRequirement
  status: 200
}
    
export type requirementsBusinessRequirementsPartialUpdateResponseSuccess = (requirementsBusinessRequirementsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsPartialUpdateResponse = (requirementsBusinessRequirementsPartialUpdateResponseSuccess)

export const getRequirementsBusinessRequirementsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/business-requirements/${id}/`
}

export const requirementsBusinessRequirementsPartialUpdate = async (id: number,
    patchedProjectBusinessRequirementRequest: PatchedProjectBusinessRequirementRequest, options?: RequestInit): Promise<requirementsBusinessRequirementsPartialUpdateResponse> => {
  
  return customFetch<requirementsBusinessRequirementsPartialUpdateResponse>(getRequirementsBusinessRequirementsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectBusinessRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirement model.

Business requirements define what the project needs to accomplish.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- problem: Filter by problem definition ID
- category: Filter by category ID

**Serializers:**
- List: ProjectBusinessRequirementListSerializer (lightweight)
- Retrieve: ProjectBusinessRequirementDetailSerializer (includes technical requirements and comments)
- Create/Update: ProjectBusinessRequirementSerializer
 */
export type requirementsBusinessRequirementsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsBusinessRequirementsDestroyResponseSuccess = (requirementsBusinessRequirementsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsBusinessRequirementsDestroyResponse = (requirementsBusinessRequirementsDestroyResponseSuccess)

export const getRequirementsBusinessRequirementsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/business-requirements/${id}/`
}

export const requirementsBusinessRequirementsDestroy = async (id: number, options?: RequestInit): Promise<requirementsBusinessRequirementsDestroyResponse> => {
  
  return customFetch<requirementsBusinessRequirementsDestroyResponse>(getRequirementsBusinessRequirementsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesListResponse200 = {
  data: PaginatedProjectBusinessRequirementEstimateList
  status: 200
}
    
export type requirementsEstimatesListResponseSuccess = (requirementsEstimatesListResponse200) & {
  headers: Headers;
};
;

export type requirementsEstimatesListResponse = (requirementsEstimatesListResponseSuccess)

export const getRequirementsEstimatesListUrl = (params?: RequirementsEstimatesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/estimates/?${stringifiedParams}` : `/api/requirements/estimates/`
}

export const requirementsEstimatesList = async (params?: RequirementsEstimatesListParams, options?: RequestInit): Promise<requirementsEstimatesListResponse> => {
  
  return customFetch<requirementsEstimatesListResponse>(getRequirementsEstimatesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesCreateResponse201 = {
  data: ProjectBusinessRequirementEstimate
  status: 201
}
    
export type requirementsEstimatesCreateResponseSuccess = (requirementsEstimatesCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsEstimatesCreateResponse = (requirementsEstimatesCreateResponseSuccess)

export const getRequirementsEstimatesCreateUrl = () => {


  

  return `/api/requirements/estimates/`
}

export const requirementsEstimatesCreate = async (projectBusinessRequirementEstimateRequest: ProjectBusinessRequirementEstimateRequest, options?: RequestInit): Promise<requirementsEstimatesCreateResponse> => {
  
  return customFetch<requirementsEstimatesCreateResponse>(getRequirementsEstimatesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementEstimateRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesRetrieveResponse200 = {
  data: ProjectBusinessRequirementEstimate
  status: 200
}
    
export type requirementsEstimatesRetrieveResponseSuccess = (requirementsEstimatesRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsEstimatesRetrieveResponse = (requirementsEstimatesRetrieveResponseSuccess)

export const getRequirementsEstimatesRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/estimates/${id}/`
}

export const requirementsEstimatesRetrieve = async (id: number, options?: RequestInit): Promise<requirementsEstimatesRetrieveResponse> => {
  
  return customFetch<requirementsEstimatesRetrieveResponse>(getRequirementsEstimatesRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesUpdateResponse200 = {
  data: ProjectBusinessRequirementEstimate
  status: 200
}
    
export type requirementsEstimatesUpdateResponseSuccess = (requirementsEstimatesUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsEstimatesUpdateResponse = (requirementsEstimatesUpdateResponseSuccess)

export const getRequirementsEstimatesUpdateUrl = (id: number,) => {


  

  return `/api/requirements/estimates/${id}/`
}

export const requirementsEstimatesUpdate = async (id: number,
    projectBusinessRequirementEstimateRequest: ProjectBusinessRequirementEstimateRequest, options?: RequestInit): Promise<requirementsEstimatesUpdateResponse> => {
  
  return customFetch<requirementsEstimatesUpdateResponse>(getRequirementsEstimatesUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectBusinessRequirementEstimateRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesPartialUpdateResponse200 = {
  data: ProjectBusinessRequirementEstimate
  status: 200
}
    
export type requirementsEstimatesPartialUpdateResponseSuccess = (requirementsEstimatesPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsEstimatesPartialUpdateResponse = (requirementsEstimatesPartialUpdateResponseSuccess)

export const getRequirementsEstimatesPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/estimates/${id}/`
}

export const requirementsEstimatesPartialUpdate = async (id: number,
    patchedProjectBusinessRequirementEstimateRequest: PatchedProjectBusinessRequirementEstimateRequest, options?: RequestInit): Promise<requirementsEstimatesPartialUpdateResponse> => {
  
  return customFetch<requirementsEstimatesPartialUpdateResponse>(getRequirementsEstimatesPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectBusinessRequirementEstimateRequest,)
  }
);}


/**
 * ViewSet for ProjectBusinessRequirementEstimate model.

Estimates for technical requirements (days and confidence level).

**Organization Scoping:**
- Regular users can only access estimates for projects in their organizations
- Superusers can access all estimates

**Filtering:**
- requirement: Filter by technical requirement ID
- project: Filter by project UUID
 */
export type requirementsEstimatesDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsEstimatesDestroyResponseSuccess = (requirementsEstimatesDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsEstimatesDestroyResponse = (requirementsEstimatesDestroyResponseSuccess)

export const getRequirementsEstimatesDestroyUrl = (id: number,) => {


  

  return `/api/requirements/estimates/${id}/`
}

export const requirementsEstimatesDestroy = async (id: number, options?: RequestInit): Promise<requirementsEstimatesDestroyResponse> => {
  
  return customFetch<requirementsEstimatesDestroyResponse>(getRequirementsEstimatesDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesListResponse200 = {
  data: PaginatedProjectTechnicalRequirementGithubIssueList
  status: 200
}
    
export type requirementsGithubIssuesListResponseSuccess = (requirementsGithubIssuesListResponse200) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesListResponse = (requirementsGithubIssuesListResponseSuccess)

export const getRequirementsGithubIssuesListUrl = (params?: RequirementsGithubIssuesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/github-issues/?${stringifiedParams}` : `/api/requirements/github-issues/`
}

export const requirementsGithubIssuesList = async (params?: RequirementsGithubIssuesListParams, options?: RequestInit): Promise<requirementsGithubIssuesListResponse> => {
  
  return customFetch<requirementsGithubIssuesListResponse>(getRequirementsGithubIssuesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesCreateResponse201 = {
  data: ProjectTechnicalRequirementGithubIssue
  status: 201
}
    
export type requirementsGithubIssuesCreateResponseSuccess = (requirementsGithubIssuesCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesCreateResponse = (requirementsGithubIssuesCreateResponseSuccess)

export const getRequirementsGithubIssuesCreateUrl = () => {


  

  return `/api/requirements/github-issues/`
}

export const requirementsGithubIssuesCreate = async (projectTechnicalRequirementGithubIssueRequest: ProjectTechnicalRequirementGithubIssueRequest, options?: RequestInit): Promise<requirementsGithubIssuesCreateResponse> => {
  
  return customFetch<requirementsGithubIssuesCreateResponse>(getRequirementsGithubIssuesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementGithubIssueRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesRetrieveResponse200 = {
  data: ProjectTechnicalRequirementGithubIssue
  status: 200
}
    
export type requirementsGithubIssuesRetrieveResponseSuccess = (requirementsGithubIssuesRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesRetrieveResponse = (requirementsGithubIssuesRetrieveResponseSuccess)

export const getRequirementsGithubIssuesRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/github-issues/${id}/`
}

export const requirementsGithubIssuesRetrieve = async (id: number, options?: RequestInit): Promise<requirementsGithubIssuesRetrieveResponse> => {
  
  return customFetch<requirementsGithubIssuesRetrieveResponse>(getRequirementsGithubIssuesRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesUpdateResponse200 = {
  data: ProjectTechnicalRequirementGithubIssue
  status: 200
}
    
export type requirementsGithubIssuesUpdateResponseSuccess = (requirementsGithubIssuesUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesUpdateResponse = (requirementsGithubIssuesUpdateResponseSuccess)

export const getRequirementsGithubIssuesUpdateUrl = (id: number,) => {


  

  return `/api/requirements/github-issues/${id}/`
}

export const requirementsGithubIssuesUpdate = async (id: number,
    projectTechnicalRequirementGithubIssueRequest: ProjectTechnicalRequirementGithubIssueRequest, options?: RequestInit): Promise<requirementsGithubIssuesUpdateResponse> => {
  
  return customFetch<requirementsGithubIssuesUpdateResponse>(getRequirementsGithubIssuesUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementGithubIssueRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesPartialUpdateResponse200 = {
  data: ProjectTechnicalRequirementGithubIssue
  status: 200
}
    
export type requirementsGithubIssuesPartialUpdateResponseSuccess = (requirementsGithubIssuesPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesPartialUpdateResponse = (requirementsGithubIssuesPartialUpdateResponseSuccess)

export const getRequirementsGithubIssuesPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/github-issues/${id}/`
}

export const requirementsGithubIssuesPartialUpdate = async (id: number,
    patchedProjectTechnicalRequirementGithubIssueRequest: PatchedProjectTechnicalRequirementGithubIssueRequest, options?: RequestInit): Promise<requirementsGithubIssuesPartialUpdateResponse> => {
  
  return customFetch<requirementsGithubIssuesPartialUpdateResponse>(getRequirementsGithubIssuesPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectTechnicalRequirementGithubIssueRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementGithubIssue model.

Links between technical requirements and GitHub issues.

**Organization Scoping:**
- Regular users can only access links for projects in their organizations
- Superusers can access all links

**Filtering:**
- technical_requirement: Filter by technical requirement ID
 */
export type requirementsGithubIssuesDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsGithubIssuesDestroyResponseSuccess = (requirementsGithubIssuesDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsGithubIssuesDestroyResponse = (requirementsGithubIssuesDestroyResponseSuccess)

export const getRequirementsGithubIssuesDestroyUrl = (id: number,) => {


  

  return `/api/requirements/github-issues/${id}/`
}

export const requirementsGithubIssuesDestroy = async (id: number, options?: RequestInit): Promise<requirementsGithubIssuesDestroyResponse> => {
  
  return customFetch<requirementsGithubIssuesDestroyResponse>(getRequirementsGithubIssuesDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsListResponse200 = {
  data: PaginatedProjectProblemDefinitionList
  status: 200
}
    
export type requirementsProblemDefinitionsListResponseSuccess = (requirementsProblemDefinitionsListResponse200) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsListResponse = (requirementsProblemDefinitionsListResponseSuccess)

export const getRequirementsProblemDefinitionsListUrl = (params?: RequirementsProblemDefinitionsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/problem-definitions/?${stringifiedParams}` : `/api/requirements/problem-definitions/`
}

export const requirementsProblemDefinitionsList = async (params?: RequirementsProblemDefinitionsListParams, options?: RequestInit): Promise<requirementsProblemDefinitionsListResponse> => {
  
  return customFetch<requirementsProblemDefinitionsListResponse>(getRequirementsProblemDefinitionsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsCreateResponse201 = {
  data: ProjectProblemDefinition
  status: 201
}
    
export type requirementsProblemDefinitionsCreateResponseSuccess = (requirementsProblemDefinitionsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsCreateResponse = (requirementsProblemDefinitionsCreateResponseSuccess)

export const getRequirementsProblemDefinitionsCreateUrl = () => {


  

  return `/api/requirements/problem-definitions/`
}

export const requirementsProblemDefinitionsCreate = async (projectProblemDefinitionRequest: ProjectProblemDefinitionRequest, options?: RequestInit): Promise<requirementsProblemDefinitionsCreateResponse> => {
  
  return customFetch<requirementsProblemDefinitionsCreateResponse>(getRequirementsProblemDefinitionsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectProblemDefinitionRequest,)
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsRetrieveResponse200 = {
  data: ProjectProblemDefinition
  status: 200
}
    
export type requirementsProblemDefinitionsRetrieveResponseSuccess = (requirementsProblemDefinitionsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsRetrieveResponse = (requirementsProblemDefinitionsRetrieveResponseSuccess)

export const getRequirementsProblemDefinitionsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/problem-definitions/${id}/`
}

export const requirementsProblemDefinitionsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsProblemDefinitionsRetrieveResponse> => {
  
  return customFetch<requirementsProblemDefinitionsRetrieveResponse>(getRequirementsProblemDefinitionsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsUpdateResponse200 = {
  data: ProjectProblemDefinition
  status: 200
}
    
export type requirementsProblemDefinitionsUpdateResponseSuccess = (requirementsProblemDefinitionsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsUpdateResponse = (requirementsProblemDefinitionsUpdateResponseSuccess)

export const getRequirementsProblemDefinitionsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/problem-definitions/${id}/`
}

export const requirementsProblemDefinitionsUpdate = async (id: number,
    projectProblemDefinitionRequest: ProjectProblemDefinitionRequest, options?: RequestInit): Promise<requirementsProblemDefinitionsUpdateResponse> => {
  
  return customFetch<requirementsProblemDefinitionsUpdateResponse>(getRequirementsProblemDefinitionsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectProblemDefinitionRequest,)
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsPartialUpdateResponse200 = {
  data: ProjectProblemDefinition
  status: 200
}
    
export type requirementsProblemDefinitionsPartialUpdateResponseSuccess = (requirementsProblemDefinitionsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsPartialUpdateResponse = (requirementsProblemDefinitionsPartialUpdateResponseSuccess)

export const getRequirementsProblemDefinitionsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/problem-definitions/${id}/`
}

export const requirementsProblemDefinitionsPartialUpdate = async (id: number,
    patchedProjectProblemDefinitionRequest: PatchedProjectProblemDefinitionRequest, options?: RequestInit): Promise<requirementsProblemDefinitionsPartialUpdateResponse> => {
  
  return customFetch<requirementsProblemDefinitionsPartialUpdateResponse>(getRequirementsProblemDefinitionsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectProblemDefinitionRequest,)
  }
);}


/**
 * ViewSet for ProjectProblemDefinition model.

Problem definitions describe the issues that a project aims to solve.

**Organization Scoping:**
- Regular users can only access problem definitions for projects in their organizations
- Superusers can access all problem definitions

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsProblemDefinitionsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsProblemDefinitionsDestroyResponseSuccess = (requirementsProblemDefinitionsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsProblemDefinitionsDestroyResponse = (requirementsProblemDefinitionsDestroyResponseSuccess)

export const getRequirementsProblemDefinitionsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/problem-definitions/${id}/`
}

export const requirementsProblemDefinitionsDestroy = async (id: number, options?: RequestInit): Promise<requirementsProblemDefinitionsDestroyResponse> => {
  
  return customFetch<requirementsProblemDefinitionsDestroyResponse>(getRequirementsProblemDefinitionsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * Schedule technical requirements and calculate estimated completion date.
 */
export type requirementsScheduleEstimationCreateResponse200 = {
  data: ScheduleEstimationResponse
  status: 200
}

export type requirementsScheduleEstimationCreateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type requirementsScheduleEstimationCreateResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type requirementsScheduleEstimationCreateResponseSuccess = (requirementsScheduleEstimationCreateResponse200) & {
  headers: Headers;
};
export type requirementsScheduleEstimationCreateResponseError = (requirementsScheduleEstimationCreateResponse400 | requirementsScheduleEstimationCreateResponse404) & {
  headers: Headers;
};

export type requirementsScheduleEstimationCreateResponse = (requirementsScheduleEstimationCreateResponseSuccess | requirementsScheduleEstimationCreateResponseError)

export const getRequirementsScheduleEstimationCreateUrl = () => {


  

  return `/api/requirements/schedule-estimation/`
}

export const requirementsScheduleEstimationCreate = async (scheduleEstimationRequestRequest: ScheduleEstimationRequestRequest, options?: RequestInit): Promise<requirementsScheduleEstimationCreateResponse> => {
  
  return customFetch<requirementsScheduleEstimationCreateResponse>(getRequirementsScheduleEstimationCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      scheduleEstimationRequestRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesListResponse200 = {
  data: PaginatedProjectTechnicalRequirementCategoryList
  status: 200
}
    
export type requirementsTechnicalRequirementCategoriesListResponseSuccess = (requirementsTechnicalRequirementCategoriesListResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesListResponse = (requirementsTechnicalRequirementCategoriesListResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesListUrl = (params?: RequirementsTechnicalRequirementCategoriesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/technical-requirement-categories/?${stringifiedParams}` : `/api/requirements/technical-requirement-categories/`
}

export const requirementsTechnicalRequirementCategoriesList = async (params?: RequirementsTechnicalRequirementCategoriesListParams, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesListResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesListResponse>(getRequirementsTechnicalRequirementCategoriesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesCreateResponse201 = {
  data: ProjectTechnicalRequirementCategory
  status: 201
}
    
export type requirementsTechnicalRequirementCategoriesCreateResponseSuccess = (requirementsTechnicalRequirementCategoriesCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesCreateResponse = (requirementsTechnicalRequirementCategoriesCreateResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesCreateUrl = () => {


  

  return `/api/requirements/technical-requirement-categories/`
}

export const requirementsTechnicalRequirementCategoriesCreate = async (projectTechnicalRequirementCategoryRequest: ProjectTechnicalRequirementCategoryRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesCreateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesCreateResponse>(getRequirementsTechnicalRequirementCategoriesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesRetrieveResponse200 = {
  data: ProjectTechnicalRequirementCategory
  status: 200
}
    
export type requirementsTechnicalRequirementCategoriesRetrieveResponseSuccess = (requirementsTechnicalRequirementCategoriesRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesRetrieveResponse = (requirementsTechnicalRequirementCategoriesRetrieveResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-categories/${id}/`
}

export const requirementsTechnicalRequirementCategoriesRetrieve = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesRetrieveResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesRetrieveResponse>(getRequirementsTechnicalRequirementCategoriesRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesUpdateResponse200 = {
  data: ProjectTechnicalRequirementCategory
  status: 200
}
    
export type requirementsTechnicalRequirementCategoriesUpdateResponseSuccess = (requirementsTechnicalRequirementCategoriesUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesUpdateResponse = (requirementsTechnicalRequirementCategoriesUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-categories/${id}/`
}

export const requirementsTechnicalRequirementCategoriesUpdate = async (id: number,
    projectTechnicalRequirementCategoryRequest: ProjectTechnicalRequirementCategoryRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesUpdateResponse>(getRequirementsTechnicalRequirementCategoriesUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesPartialUpdateResponse200 = {
  data: ProjectTechnicalRequirementCategory
  status: 200
}
    
export type requirementsTechnicalRequirementCategoriesPartialUpdateResponseSuccess = (requirementsTechnicalRequirementCategoriesPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesPartialUpdateResponse = (requirementsTechnicalRequirementCategoriesPartialUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-categories/${id}/`
}

export const requirementsTechnicalRequirementCategoriesPartialUpdate = async (id: number,
    patchedProjectTechnicalRequirementCategoryRequest: PatchedProjectTechnicalRequirementCategoryRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesPartialUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesPartialUpdateResponse>(getRequirementsTechnicalRequirementCategoriesPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectTechnicalRequirementCategoryRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementCategory model.

Categories for organizing technical requirements within a project.

**Organization Scoping:**
- Regular users can only access categories for projects in their organizations
- Superusers can access all categories

**Filtering:**
- project: Filter by project UUID
 */
export type requirementsTechnicalRequirementCategoriesDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsTechnicalRequirementCategoriesDestroyResponseSuccess = (requirementsTechnicalRequirementCategoriesDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCategoriesDestroyResponse = (requirementsTechnicalRequirementCategoriesDestroyResponseSuccess)

export const getRequirementsTechnicalRequirementCategoriesDestroyUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-categories/${id}/`
}

export const requirementsTechnicalRequirementCategoriesDestroy = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementCategoriesDestroyResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCategoriesDestroyResponse>(getRequirementsTechnicalRequirementCategoriesDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsListResponse200 = {
  data: PaginatedProjectTechnicalRequirementCommentList
  status: 200
}
    
export type requirementsTechnicalRequirementCommentsListResponseSuccess = (requirementsTechnicalRequirementCommentsListResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsListResponse = (requirementsTechnicalRequirementCommentsListResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsListUrl = (params?: RequirementsTechnicalRequirementCommentsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/technical-requirement-comments/?${stringifiedParams}` : `/api/requirements/technical-requirement-comments/`
}

export const requirementsTechnicalRequirementCommentsList = async (params?: RequirementsTechnicalRequirementCommentsListParams, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsListResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsListResponse>(getRequirementsTechnicalRequirementCommentsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsCreateResponse201 = {
  data: ProjectTechnicalRequirementComment
  status: 201
}
    
export type requirementsTechnicalRequirementCommentsCreateResponseSuccess = (requirementsTechnicalRequirementCommentsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsCreateResponse = (requirementsTechnicalRequirementCommentsCreateResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsCreateUrl = () => {


  

  return `/api/requirements/technical-requirement-comments/`
}

export const requirementsTechnicalRequirementCommentsCreate = async (projectTechnicalRequirementCommentRequest: ProjectTechnicalRequirementCommentRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsCreateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsCreateResponse>(getRequirementsTechnicalRequirementCommentsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsRetrieveResponse200 = {
  data: ProjectTechnicalRequirementComment
  status: 200
}
    
export type requirementsTechnicalRequirementCommentsRetrieveResponseSuccess = (requirementsTechnicalRequirementCommentsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsRetrieveResponse = (requirementsTechnicalRequirementCommentsRetrieveResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-comments/${id}/`
}

export const requirementsTechnicalRequirementCommentsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsRetrieveResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsRetrieveResponse>(getRequirementsTechnicalRequirementCommentsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsUpdateResponse200 = {
  data: ProjectTechnicalRequirementComment
  status: 200
}
    
export type requirementsTechnicalRequirementCommentsUpdateResponseSuccess = (requirementsTechnicalRequirementCommentsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsUpdateResponse = (requirementsTechnicalRequirementCommentsUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-comments/${id}/`
}

export const requirementsTechnicalRequirementCommentsUpdate = async (id: number,
    projectTechnicalRequirementCommentRequest: ProjectTechnicalRequirementCommentRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsUpdateResponse>(getRequirementsTechnicalRequirementCommentsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsPartialUpdateResponse200 = {
  data: ProjectTechnicalRequirementComment
  status: 200
}
    
export type requirementsTechnicalRequirementCommentsPartialUpdateResponseSuccess = (requirementsTechnicalRequirementCommentsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsPartialUpdateResponse = (requirementsTechnicalRequirementCommentsPartialUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-comments/${id}/`
}

export const requirementsTechnicalRequirementCommentsPartialUpdate = async (id: number,
    patchedProjectTechnicalRequirementCommentRequest: PatchedProjectTechnicalRequirementCommentRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsPartialUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsPartialUpdateResponse>(getRequirementsTechnicalRequirementCommentsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectTechnicalRequirementCommentRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirementComment model.

Comments on technical requirements with nested reply support.

**Organization Scoping:**
- Regular users can only access comments for projects in their organizations
- Superusers can access all comments

**Filtering:**
- requirement: Filter by technical requirement ID
- top_level_only: Return only top-level comments (true/false)
 */
export type requirementsTechnicalRequirementCommentsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsTechnicalRequirementCommentsDestroyResponseSuccess = (requirementsTechnicalRequirementCommentsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementCommentsDestroyResponse = (requirementsTechnicalRequirementCommentsDestroyResponseSuccess)

export const getRequirementsTechnicalRequirementCommentsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirement-comments/${id}/`
}

export const requirementsTechnicalRequirementCommentsDestroy = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementCommentsDestroyResponse> => {
  
  return customFetch<requirementsTechnicalRequirementCommentsDestroyResponse>(getRequirementsTechnicalRequirementCommentsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsListResponse200 = {
  data: PaginatedProjectTechnicalRequirementList
  status: 200
}
    
export type requirementsTechnicalRequirementsListResponseSuccess = (requirementsTechnicalRequirementsListResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsListResponse = (requirementsTechnicalRequirementsListResponseSuccess)

export const getRequirementsTechnicalRequirementsListUrl = (params?: RequirementsTechnicalRequirementsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/requirements/technical-requirements/?${stringifiedParams}` : `/api/requirements/technical-requirements/`
}

export const requirementsTechnicalRequirementsList = async (params?: RequirementsTechnicalRequirementsListParams, options?: RequestInit): Promise<requirementsTechnicalRequirementsListResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsListResponse>(getRequirementsTechnicalRequirementsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsCreateResponse201 = {
  data: ProjectTechnicalRequirement
  status: 201
}
    
export type requirementsTechnicalRequirementsCreateResponseSuccess = (requirementsTechnicalRequirementsCreateResponse201) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsCreateResponse = (requirementsTechnicalRequirementsCreateResponseSuccess)

export const getRequirementsTechnicalRequirementsCreateUrl = () => {


  

  return `/api/requirements/technical-requirements/`
}

export const requirementsTechnicalRequirementsCreate = async (projectTechnicalRequirementRequest: ProjectTechnicalRequirementRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementsCreateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsCreateResponse>(getRequirementsTechnicalRequirementsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsRetrieveResponse200 = {
  data: ProjectTechnicalRequirementDetail
  status: 200
}
    
export type requirementsTechnicalRequirementsRetrieveResponseSuccess = (requirementsTechnicalRequirementsRetrieveResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsRetrieveResponse = (requirementsTechnicalRequirementsRetrieveResponseSuccess)

export const getRequirementsTechnicalRequirementsRetrieveUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirements/${id}/`
}

export const requirementsTechnicalRequirementsRetrieve = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementsRetrieveResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsRetrieveResponse>(getRequirementsTechnicalRequirementsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsUpdateResponse200 = {
  data: ProjectTechnicalRequirement
  status: 200
}
    
export type requirementsTechnicalRequirementsUpdateResponseSuccess = (requirementsTechnicalRequirementsUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsUpdateResponse = (requirementsTechnicalRequirementsUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementsUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirements/${id}/`
}

export const requirementsTechnicalRequirementsUpdate = async (id: number,
    projectTechnicalRequirementRequest: ProjectTechnicalRequirementRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementsUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsUpdateResponse>(getRequirementsTechnicalRequirementsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTechnicalRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsPartialUpdateResponse200 = {
  data: ProjectTechnicalRequirement
  status: 200
}
    
export type requirementsTechnicalRequirementsPartialUpdateResponseSuccess = (requirementsTechnicalRequirementsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsPartialUpdateResponse = (requirementsTechnicalRequirementsPartialUpdateResponseSuccess)

export const getRequirementsTechnicalRequirementsPartialUpdateUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirements/${id}/`
}

export const requirementsTechnicalRequirementsPartialUpdate = async (id: number,
    patchedProjectTechnicalRequirementRequest: PatchedProjectTechnicalRequirementRequest, options?: RequestInit): Promise<requirementsTechnicalRequirementsPartialUpdateResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsPartialUpdateResponse>(getRequirementsTechnicalRequirementsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedProjectTechnicalRequirementRequest,)
  }
);}


/**
 * ViewSet for ProjectTechnicalRequirement model.

Technical requirements (é–‹ç™ºè¦ä»¶) linked to business requirements.

**Organization Scoping:**
- Regular users can only access requirements for projects in their organizations
- Superusers can access all requirements

**Filtering:**
- project: Filter by project UUID
- business_requirement: Filter by business requirement ID
- category: Filter by category ID

**Serializers:**
- List/Create/Update: ProjectTechnicalRequirementSerializer
- Retrieve: ProjectTechnicalRequirementDetailSerializer (includes comments)
 */
export type requirementsTechnicalRequirementsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type requirementsTechnicalRequirementsDestroyResponseSuccess = (requirementsTechnicalRequirementsDestroyResponse204) & {
  headers: Headers;
};
;

export type requirementsTechnicalRequirementsDestroyResponse = (requirementsTechnicalRequirementsDestroyResponseSuccess)

export const getRequirementsTechnicalRequirementsDestroyUrl = (id: number,) => {


  

  return `/api/requirements/technical-requirements/${id}/`
}

export const requirementsTechnicalRequirementsDestroy = async (id: number, options?: RequestInit): Promise<requirementsTechnicalRequirementsDestroyResponse> => {
  
  return customFetch<requirementsTechnicalRequirementsDestroyResponse>(getRequirementsTechnicalRequirementsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


